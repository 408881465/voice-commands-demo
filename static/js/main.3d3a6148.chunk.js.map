{"version":3,"sources":["utils.js","recognize.js","App.js","serviceWorker.js","index.js"],"names":["Utils","Object","classCallCheck","this","createClass","key","value","window","performance","now","timing","navigationStart","Date","view","offset","string","lng","length","i","setUint8","charCodeAt","channelBuffer","result","Float32Array","buffer","set","internalLeftChannel","internalRecordingLength","interleaved","mergeBuffers","ArrayBuffer","DataView","writeUTFBytes","setUint32","setUint16","sampleRate","numChannels","index","setInt16","Blob","type","blob","timeInterval","a","document","createElement","target","innerHTML","href","URL","createObjectURL","$","html","Meyda","require","DynamicTimeWarping","Recognize","_buffer","transcript","setStateFunc","bufferSize","bufferMfcc","createMfccMetric","mfccHistoryArr","push","mfcc","mfccHistoryCunters","console","log","knnClosest","startTime","getTimestamp","calculateDistanceArr","mfccDistArr","K_factor","getMostSimilarKnn","compareMfcc","_minNumberOfVariants","confidence","_minKnnConfidence","endTime","processTime","isInDictionary","dist","EuclideanDistance","getDistance","word","dictionary","Items","CompFunc","k","items","compFunc","sort","kArr","slice","simArr","maxElm","weight","_minDTWDist","sum","count","getGaussianKernel","toFixed","t","Math","pow","E","mfccMetricArr","_buffArrSize","mfccMetric","extract","p","q","d","sqrt","b","calibMode","hark","App","props","_this","possibleConstructorReturn","getPrototypeOf","call","onMediaSuccess","stream","state","trained","setState","currentTrainingIndex","msg","audioContextType","AudioContext","webkitAudioContext","localStream","track","getTracks","context","source","createMediaStreamSource","createScriptProcessor","node","createJavaScriptNode","onaudioprocess","e","left","inputBuffer","getChannelData","recording","leftchannel","recordingLength","splice","connect","destination","speechHark","interval","_harkInterval","threshold","_threshold","play","recoredInterval","_stopRecTimeout","on","statusMsg","setTimeout","stopRec","bufferToBlob","getVoiceFile","reader","FileReader","readAsDataURL","onloadend","recognize","setStateMsgFunc","success","train","traingNextWord","modeMsg","stopUserMediaTrack","stop","stopListening","start","startListening","localstream","navigator","mediaDevices","getUserMedia","audio","react_default","className","onClick","id","Component","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3d3a6148.chunk.js","sourcesContent":["import $ from 'jquery';\n\nexport class Utils {\n\n    static getTimestamp() {\n        var timeStampInMs = window.performance && window.performance.now && window.performance.timing && window.performance.timing.navigationStart ? window.performance.now() + window.performance.timing.navigationStart : Date.now();\n        return timeStampInMs;\n    }\n\n    /******************************************************************************\n    * blob and buffer works\n    ******************************************************************************/\n    static writeUTFBytes(view, offset, string) {\n        var lng = string.length;\n        for (var i = 0; i < lng; i++) {\n            view.setUint8(offset + i, string.charCodeAt(i));\n        }\n    }\n\n\n    static mergeBuffers(channelBuffer) {\n        if (channelBuffer.length === 0)\n            return;\n        var result = new Float32Array(channelBuffer.length * channelBuffer[0].length);\n        var offset = 0;\n        var lng = channelBuffer.length;\n        for (var i = 0; i < lng; i++) {\n            var buffer = channelBuffer[i];\n            result.set(buffer, offset);\n            offset += buffer.length;\n        }\n        return result;\n    }\n\n\n\n    static bufferToBlob(internalLeftChannel, internalRecordingLength) {\n\n        var interleaved = this.mergeBuffers(internalLeftChannel, internalRecordingLength);\n        if (!interleaved)\n            return;\n\n        var numChannels = 1, sampleRate = 48000;\n        // we create our wav file\n        var buffer = new ArrayBuffer(44 + interleaved.length * 2);\n        var view = new DataView(buffer);\n\n        // RIFF chunk descriptor\n        this.writeUTFBytes(view, 0, 'RIFF');\n\n        // -8 (via #97)\n        view.setUint32(4, 44 + interleaved.length * 2 - 8, true);\n\n        this.writeUTFBytes(view, 8, 'WAVE');\n        // FMT sub-chunk\n        this.writeUTFBytes(view, 12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        // stereo (2 channels)\n        view.setUint16(22, numChannels, true);\n        view.setUint32(24, sampleRate, true);\n        view.setUint32(28, sampleRate * numChannels * 2, true); // numChannels * 2 (via #71)\n        view.setUint16(32, numChannels * 2, true);\n        view.setUint16(34, 16, true);\n        // data sub-chunk\n        this.writeUTFBytes(view, 36, 'data');\n        view.setUint32(40, interleaved.length * 2, true);\n\n        // write the PCM samples\n        var lng = interleaved.length;\n        var index = 44;\n        var volume = 1;\n        for (var i = 0; i < lng; i++) {\n            view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n            index += 2;\n        }\n\n        // our final binary blob\n        var blob = new Blob([view], {\n            type: 'audio/wav'\n        });\n\n        return blob;\n    }\n\n    /******************************************************************************\n    * for debugging, use the following method to get voice file\n    ******************************************************************************/\n\n    static getVoiceFile(blob, timeInterval) {\n\n        if (!blob)\n            return;\n\n        var a = document.createElement('a');\n        a.target = '_blank';\n        a.innerHTML = 'Open Recorded Audio';\n        a.href = URL.createObjectURL(blob);\n        $('#audios-container').html(a);\n    };\n\n}\n","import { Utils } from './utils.js'\n\nvar Meyda = require('meyda')\nvar DynamicTimeWarping = require('dynamic-time-warping')\n\nexport class Recognize {\n\n    /******************************************************************************\n  * Local Recognition and MFCC/DTW calculations \n  * MFCC by Meyda: https://github.com/meyda/meyda\n  * DTW: https://github.com/GordonLesti/dynamic-time-warping\n  ******************************************************************************/\n\n    // you can try and tune these variables\n    static startTime = null;\n    static endTime = null;\n    static calibMode = false;\n    static mfccHistoryArr = [];\n    static mfccHistoryCunters = [];\n    static dictionary = ['one', 'two', 'three'];\n    // static dictionary = ['left', 'right', 'up', 'down']; \n    static bufferSize = 2048;\n    static _buffArrSize = 40;      // 40   / 70\n    static _minNumberOfVariants = 2;\n    static _minKnnConfidence = 0;\n    static _minDTWDist = 1000;\n    static K_factor = 3;\n\n    static mfccDistArr = [];\n\n    static bufferMfcc;\n    static buffer = {};\n\n    /**\n     * train the system, assume that the passed audio data in the buffer fits the transcript\n     * @param {*} _buffer \n     * @param {*} transcript \n     * @param {*} setStateFunc \n     */\n    static train(_buffer, transcript, setStateFunc) {\n        setStateFunc(\"training\");\n        this.buffer = _buffer;\n        Meyda.bufferSize = this.bufferSize;\n\n        // calculate mfcc data\n        this.bufferMfcc = this.createMfccMetric();\n\n        // save current mfcc for future recognitions\n        this.mfccHistoryArr.push({\n            mfcc: this.bufferMfcc,\n            transcript: transcript\n        });\n\n        if (!this.mfccHistoryCunters[transcript] && this.mfccHistoryCunters[transcript] !== 0)\n            this.mfccHistoryCunters[transcript] = 0;\n        this.mfccHistoryCunters[transcript]++;\n\n        console.log(this.bufferMfcc);\n        console.log(this.mfccHistoryArr);\n\n        setStateFunc(\"training saved\");\n        return true;\n    }\n\n    /**\n     * try to recognize what the audio data in the buffer is\n     * @param {*} _buffer \n     * @param {*} setStateFunc \n     */\n    static recognize(_buffer, setStateFunc) {\n        this.buffer = _buffer;\n        Meyda.bufferSize = this.bufferSize;\n\n        // calculate mfcc data\n        this.bufferMfcc = this.createMfccMetric();\n\n        console.log(this.bufferMfcc);\n\n        this.startTime = Utils.getTimestamp();\n        setStateFunc(\"recognizing\");\n\n        // calculate DTW distance from all available trained data\n        this.calculateDistanceArr();\n        console.log(this.mfccDistArr);\n\n        // get closest one using knn\n        var knnClosest;\n        if (this.K_factor <= this.mfccHistoryArr.length) {\n            knnClosest = this.getMostSimilarKnn(this.mfccDistArr, this.compareMfcc, this.K_factor);\n            if (knnClosest &&\n                (this.mfccHistoryCunters[knnClosest.transcript] < this._minNumberOfVariants\n                    || knnClosest.confidence < this._minKnnConfidence))\n                knnClosest = null;\n\n            if (knnClosest && knnClosest.transcript !== \"\") {\n                // save current mfcc for next recognitions\n                this.mfccHistoryArr.push({\n                    mfcc: this.bufferMfcc,\n                    transcript: knnClosest.transcript\n                });\n                if (!this.mfccHistoryCunters[knnClosest.transcript] && this.mfccHistoryCunters[knnClosest.transcript] !== 0)\n                    this.mfccHistoryCunters[knnClosest.transcript] = 0;\n                this.mfccHistoryCunters[knnClosest.transcript]++;\n            }\n\n        }\n\n        // validate that we have minimal recognition confidence\n        if (!knnClosest || knnClosest.confidence < 0.75) {\n            this.endTime = Utils.getTimestamp();\n            setStateFunc(\"not recognized\");\n            console.log(\"recognition locally failed or returned no good result (\" + (this.endTime - this.startTime) + \" ms)\");\n            return null;\n        }\n        else {\n            knnClosest.processTime = Utils.getTimestamp() - this.startTime;\n        }\n        setStateFunc(\"recognized\");\n        return knnClosest;\n    };\n\n\n    /**\n     * calculate DTW distance from dictionary mfcc history\n     */\n    static calculateDistanceArr() {\n        this.mfccDistArr = [];\n        for (var i = 0; i < this.mfccHistoryArr.length; i++) {\n            if (this.isInDictionary(this.mfccHistoryArr[i].transcript)) {\n                var dtw = new DynamicTimeWarping(this.mfccHistoryArr[i].mfcc, this.bufferMfcc, this.EuclideanDistance);\n                var dist = dtw.getDistance();\n                this.mfccDistArr.push({\n                    dist: dist,\n                    transcript: this.mfccHistoryArr[i].transcript\n                });\n            }\n        }\n    }\n\n\n    /**\n     * search in dictionary\n     */\n    static isInDictionary(word) {\n        for (var i = 0; i < this.dictionary.length; i++) {\n            if (this.dictionary[i] === word)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * get the most similar transcript from audio mfcc history array, using Knn Algorithm\n     * @param {*} Items \n     * @param {*} CompFunc \n     * @param {*} k \n     */\n    static getMostSimilarKnn(Items, CompFunc, k) {\n        if (!Items || Items.length === 0)\n            return;\n        if (k > Items.length)\n            return;\n        var items = Items;\n        var compFunc = CompFunc;\n\n        items.sort(compFunc);\n        var kArr = items.slice(0, k);\n        var simArr = [];\n        var maxElm = {\n            transcript: '',\n            weight: 0,\n            confidence: 0\n        };\n\n        for (var i = 0; i < kArr.length; i++) {\n            if (kArr[i].dist > this._minDTWDist)\n                continue;\n\n            if (!simArr[kArr[i].transcript])\n                simArr[kArr[i].transcript] = {\n                    weight: 1000 / kArr[i].dist,\n                }\n            else {\n                simArr[kArr[i].transcript].weight = simArr[kArr[i].transcript].weight + 1000 / kArr[i].dist;\n            }\n\n            if (maxElm.weight < simArr[kArr[i].transcript].weight) {\n                maxElm = {\n                    transcript: kArr[i].transcript,\n                    weight: simArr[kArr[i].transcript].weight,\n                };\n            }\n        }\n\n        if (maxElm && maxElm.transcript === '')\n            maxElm = null;\n\n        if (maxElm) {\n            // calculate confidence\n            var sum = 0, count = 0;\n            for (i = 0; i < items.length; i++) {\n                if (items[i].transcript === maxElm.transcript) {\n                    sum = sum + items[i].dist;\n                    count++;\n                }\n            }\n            maxElm.confidence = this.getGaussianKernel(sum / count).toFixed(4);\n        }\n        return maxElm;\n    }\n\n    // \n    static getGaussianKernel(t) {\n        return Math.pow(Math.E, -1 / 2 * Math.pow(t / 1000, 2));\n    }\n\n    /**\n     * calculate audio buffer mfcc data\n     */\n    static createMfccMetric() {\n        var mfccMetricArr = [];\n        for (var i = 0; i < this._buffArrSize; i++) {\n            if (this.buffer[i] && this.buffer[i].length === this.bufferSize) {\n                var mfccMetric = Meyda.extract(\"mfcc\", this.buffer[i]);\n                mfccMetricArr.push(mfccMetric)\n            }\n        }\n\n        return mfccMetricArr;\n    }\n\n    /**\n     * Euclidean Distance between two victors\n     * @param {*} p \n     * @param {*} q \n     */\n    static EuclideanDistance(p, q) {\n        var d = 0;\n        if (p.length !== q.length)\n            return -1;\n        for (var i = 0; i < p.length; i++) {\n            d = d + Math.pow(p[i] - q[i], 2);\n        }\n        return Math.sqrt(d);\n    }\n\n    /**\n     * Mfcc object comparison\n     * @param {*} a \n     * @param {*} b \n     */\n    static compareMfcc(a, b) {\n        if (a.dist < b.dist)\n            return -1;\n        if (a.dist > b.dist)\n            return 1;\n        return 0;\n    }\n}","import React, { Component } from 'react';\nimport './App.css';\nimport { Utils } from './utils.js'\nimport { Recognize } from './recognize';\n\nvar hark = require('hark')\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      msg: \"click start\",\n      modeMsg: \"\",\n      statusMsg: \"\",\n      trained: false,\n      currentTrainingIndex: null,\n      result: ''\n    }\n    /******************************************************************************************************/\n\n    /*********  Voice *********/\n    this.audioContextType = null;\n    this.localstream = null;\n    this.context = null;\n    this.track = null;\n    this.node = null;\n    this.recording = true;\n    this.speechHark = null;\n    this.leftchannel = [];\n\n    /********* Settings *********/\n    this._stopRecTimeout = 1000;\n    this._threshold = -50; // voice dB\n    this._harkInterval = 100;\n    this.recordingLength = 0;\n    this.numChannels = 1;\n  }\n\n  /**\n   * This function will run if the microphone was successfully acquired.\n   * Here we record the data and make a signal when there is a speech start recognized\n   */\n  onMediaSuccess = (stream) => {\n    if (!this.state.trained) {\n      this.setState({\n        currentTrainingIndex: 0,\n        msg: \"say the next word loud and clear, and wait until we process it.  ===>   \" + Recognize.dictionary[0]\n      });\n    }\n    this.audioContextType = window.AudioContext || window.webkitAudioContext;\n    this.localStream = stream;\n    this.track = this.localStream.getTracks()[0];\n    // create the MediaStreamAudioSourceNode\n    // Setup Audio Context\n    this.context = new this.audioContextType();\n    var source = this.context.createMediaStreamSource(this.localStream);\n\n    // create a ScriptProcessorNode\n    if (!this.context.createScriptProcessor) {\n      this.node = this.context.createJavaScriptNode(Recognize.bufferSize, this.numChannels, this.numChannels);\n    } else {\n      this.node = this.context.createScriptProcessor(Recognize.bufferSize, this.numChannels, this.numChannels);\n    }\n\n    // listen to the audio data, and record into the buffer, this is important to catch the fraction of second before the speech started.\n    this.node.onaudioprocess = (e) => {\n\n      var left = e.inputBuffer.getChannelData(0);\n\n      if (!this.recording) return;\n      if (this.leftchannel.length < Recognize._buffArrSize) {\n        this.leftchannel.push(new Float32Array(left));\n        this.recordingLength += this.bufferSize;\n      }\n      else {\n        this.leftchannel.splice(0, 1);\n        this.leftchannel.push(new Float32Array(left));\n      }\n    }\n\n    // connect the ScriptProcessorNode with the input audio\n    source.connect(this.node);\n    this.node.connect(this.context.destination);\n\n    // hark: https://github.com/otalk/hark\n    // detect a speech start\n    this.speechHark = hark(this.localStream, { interval: this._harkInterval, threshold: this._threshold, play: false, recoredInterval: this._stopRecTimeout });\n    this.speechHark.on('speaking', () => {\n      this.setState({ statusMsg: \"recoding\" });\n      setTimeout(() => { this.stopRec(); }, this._stopRecTimeout);\n    });\n    this.speechHark.on('stopped_speaking', () => {\n    });\n  }\n\n  /**\n   * stop recording data in the buffer, and process the signal\n   */\n  stopRec = () => {\n    this.setState({ statusMsg: 'stopped recoding' });\n    this.recording = false;\n    var internalLeftChannel = this.leftchannel.slice(0);\n    var internalRecordingLength = this.recordingLength;\n\n    // create blob to process it\n    var blob = Utils.bufferToBlob(internalLeftChannel, internalRecordingLength);\n\n    if (!blob)\n      return;\n\n    // create a WAV file to listen to the recorded data\n    Utils.getVoiceFile(blob, 0);\n\n    var reader = new window.FileReader();\n    reader.readAsDataURL(blob);\n\n    // read the blob and start processing according to the system state (trained or not)\n    reader.onloadend = () => {\n      if (this.state.trained) {\n        let result = Recognize.recognize(internalLeftChannel, this.setStateMsgFunc);\n        if (result) {\n          this.setState({\n            msg: \"Great! the result is ===> \" + result.transcript + \" <=== try more.\"\n          });\n        }\n        else {\n          this.setState({\n            msg: \"Didn't Got it! please try to Again loud and clear.\"\n          });\n        }\n        console.log(result);\n      }\n      else {\n        let success = Recognize.train(internalLeftChannel, Recognize.dictionary[this.state.currentTrainingIndex % Recognize.dictionary.length], this.setStateMsgFunc);\n        this.traingNextWord(success);\n\n      }\n    }\n\n    this.leftchannel.length = 0;\n    this.recordingLength = 0;\n    this.recording = true;\n  };\n\n  /**\n   * Move to the next word to train the system.\n   * Train the whole dictionary twice\n   */\n  traingNextWord = (success) => {\n    if (success) {\n      // next word\n      let i = this.state.currentTrainingIndex + 1;\n      if (i > Recognize.dictionary.length * 2 - 1) {\n        this.setState({\n          trained: true,\n          currentTrainingIndex: i,\n          msg: \"training is finished, now we will try to guess what you are trying to say from the trained vocabulary.\",\n          modeMsg: \"recognizing mode\"\n        })\n      }\n      else {\n        this.setState({\n          currentTrainingIndex: i,\n          msg: \"Good! say the next word loud and clear, and wait until we process it.  ===>  \" + Recognize.dictionary[i % Recognize.dictionary.length]\n        })\n      }\n    }\n    else {\n      this.setState({\n        msg: \"we didn't got it, try again, say the next word loud and clear, and wait until we process it.    \" + Recognize.dictionary[this.state.currentTrainingIndex % Recognize.dictionary.length]\n      })\n    }\n  }\n\n  setStateMsgFunc = (msg) => {\n    this.setState({ statusMsg: msg });\n  }\n\n  stopUserMediaTrack = () => {\n    if (this.track) this.track.stop();\n  }\n\n  /**\n   * Start listening to media devices\n   */\n  async startListening() {\n\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    this.onMediaSuccess(stream);\n\n  };\n\n  /**\n   * Stop listening to media devices, and empty all buffers and streams\n   */\n  stopListening = () => {\n    this.recording = false;\n    if (this.leftchannel) {\n      this.leftchannel.length = 0;\n      this.leftchannel = [];\n    }\n    this.localStream = null;\n    this.recordingLength = 0;\n    if (this.speechHark) this.speechHark.stop();\n    if (this.stopUserMediaTrack) this.stopUserMediaTrack();\n  };\n\n  /******************************************************************************************************/\n  /** React */\n\n  start = () => {\n    this.startListening()\n    if (!this.state.trained) {\n      this.setState({\n        modeMsg: \"training mode\",\n      });\n    }\n    else {\n      this.setState({\n        modeMsg: \"recognizing mode\"\n      });\n    }\n  }\n\n  stop = () => {\n    this.stopListening()\n    this.setState({\n      statusMsg: \"stoped\"\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"row\">\n          <button onClick={this.start}>Start</button>\n          <button onClick={this.stop}>Stop</button>\n        </div>\n        <div className=\"msgs\">\n          <span>{this.state.modeMsg}</span>\n        </div>\n        <div className=\"msgs\">\n          <span>{this.state.msg}</span>\n        </div>\n        <div className=\"msgs\">\n          <span>{this.state.statusMsg}</span>\n        </div>\n        <div id=\"audios-container\"></div>\n      </div>\n    );\n  }\n}\n\n\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}